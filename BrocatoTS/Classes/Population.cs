using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace BrocatoTS.Classes
{
    class Population
    {
        //Default constructor for a population object, it is only meant to call upon methods
        public Population()
        {

        }

        //Helper object to help with some of the moethods
        Helper h = new Helper();

        //This code originated from a sample provided by Professor Wilkins, the instructor for this course. I have modified it to work in C#
        //I have also changed the frequency of values and the bias
        public Route Selection(List<Route> routes)
        {
            Random r = new Random(Guid.NewGuid().GetHashCode());
            Route parent = new Route();
            double chance = r.NextDouble();
            int index;

            //Takes in an ordered route list by the size. Depending on the percent generated by chance, it determines the frequency of what parents are selected

            //5%
            if(chance <= .05)
            {
                index = r.Next(96, 100) - 1;
                parent = routes[index];
            }
            //20%
            else if(chance <= .25)
            {
                index = r.Next(76, 95) - 1;
                parent = routes[index];
            }
            //25%
            else if(chance <= .50)
            {
                index = r.Next(51, 75) - 1;
                parent = routes[index];
            }
            //50%
            else if(chance <= 1)
            {
                index = r.Next(1, 50) - 1;
                parent = routes[index];
            }


            return parent;
        }

        //Single point crossover in order to create new children
        public Route Crossover(Route parent1, Route parent2)
        {
            List<Planet> planetOrder = new List<Planet>();

            Random randomPoint = new Random(Guid.NewGuid().GetHashCode());
            int crossoverPoint = randomPoint.Next(0, parent1.Planets.Count);

            //Adds to the child everything from parent1 before and at the crossover point
            for(int i = 0; i <= crossoverPoint; i++)
            {
                planetOrder.Add(parent1.Planets.ElementAt(i));
            }

            //Adds to the child everything from paren2 after the crossover point
            for(int i = 0; i <= parent2.Planets.Count - 1; i++)
            {
                if(!planetOrder.Contains(parent2.Planets.ElementAt(i)))
                {
                    planetOrder.Add(parent2.Planets.ElementAt(i));
                }
            }

            //Creates a child
            Route child = new Route(planetOrder);
            return child;
        }

        //Swap mutation for a solution
        public Route SwapMutation(Route solution)
        {
            Route mutatedSolution = solution;
            Random r = new Random(Guid.NewGuid().GetHashCode());

            //Creates two points to swap
            int firstSwapPoint = r.Next(0, solution.Planets.Count());
            int secondSwapPoint = r.Next(0, solution.Planets.Count());

            //Ensures the two points are unique
            while (firstSwapPoint == secondSwapPoint)
            {
                secondSwapPoint = r.Next(0, solution.Planets.Count());
            }


            //Copies the first swapPoint, overwrites the first with the second, and then overwrites the second with the temp
            Planet temp = mutatedSolution.Planets[firstSwapPoint];
            mutatedSolution.Planets[firstSwapPoint] = mutatedSolution.Planets[secondSwapPoint];
            mutatedSolution.Planets[secondSwapPoint] = temp;

            //returns the new solution
            return mutatedSolution;
        }
        
        //Creates randomized solutions as a starting point
        public List<Route> InitialPopulation(List<Planet> initialPlanets)
        {
            List<Planet> planets = new List<Planet>();
            List<Route> population = new List<Route>();

            //Shuffles the planets in the route until there are 100 solutions
            for(int i = 0; i <= 99; i++)
            {
                planets = h.ShufflePlanets(initialPlanets);
                Route r = new Route(planets);
                population.Add(r);
            }

            //Returns the solutions
            return population;
        }
    }
}
